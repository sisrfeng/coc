
==============================================================================
Key mappings						*coc-key-mappings*

    There're some cases that local key-mappings are enabled for current buffer.

        Snippet jump key-mappings when snippet is activated:
        |g:coc_snippet_prev| and |g:coc_snippet_next|.

        Cursor jump and cancel key-mappings when cursors is activated
        |coc-config-cursors|.

        Dialog key-mappings for confirm and cancel dialog window
        |coc-config-dialog|.

        Key-mappings for |CocList| buffer: |coc-list-mappings|.

    Use |:verbose| command to check key-mappings that taking effect.

    Use 'noremap' with <Plug> will make the key-mapping not work at all.

    <Plug> key-mappings are provided for convenient,
        use |CocActionAsync()| or  |CocAction()| for more options.

    Normal mode key-mappings:~

        *<Plug>(coc-diagnostic-info)* Show diagnostic message of current position by
        invoke |CocAction('diagnosticInfo')|

        *<Plug>(coc-diagnostic-next)* Jump to next diagnostic position.

        *<Plug>(coc-diagnostic-prev)* Jump to previous diagnostic position.

        *<Plug>(coc-diagnostic-next-error)* Jump to next diagnostic error position.

        *<Plug>(coc-diagnostic-prev-error)* Jump to previous diagnostic error position.

        *<Plug>(coc-definition)* Jump to definition(s) of current symbol by invoke
        |CocAction('jumpDefinition')|

        *<Plug>(coc-declaration)* Jump to declaration(s) of current symbol by invoke
        |CocAction('jumpDeclaration')|

        *<Plug>(coc-implementation)* Jump to implementation(s) of current symbol by
        invoke |CocAction('jumpImplementation')|

        *<Plug>(coc-type-definition)* Jump to type definition(s) of current symbol by
        invoke |CocAction('jumpTypeDefinition')|


        *<Plug>(coc-references)* Jump to references of current symbol by
        invoke |CocAction('jumpReferences')|


        *<Plug>(coc-references-used)* Jump to references of current symbol exclude
        declarations.

        *<Plug>(coc-format-selected)*

            Format selected range, works on both |visual-mode| and |normal-mode|,
            when used in normal mode, the selection works on the motion object.

            For example:


            vmap <leader>p  <Plug>(coc-format-selected)
            nmap <leader>p  <Plug>(coc-format-selected)

            makes `<leader>p` format the visually selected range, and you can use
            `<leader>pap` to format a paragraph.

        *<Plug>(coc-format)* Format the whole buffer by invoke |CocAction('format')|
        *<Plug>(coc-rename)* Rename symbol under cursor to a new word by invoke
        |CocAction('rename')|

        *<Plug>(coc-refactor)* Open refactor window for refactor of current symbol by
        invoke |CocAction('refactor')|

        *<Plug>(coc-command-repeat)* Repeat latest |CocCommand|.

        *<Plug>(coc-codeaction)* Get and run code action(s) for current file, use
        |coc-codeaction-cursor| for same behavior as VSCode.

        *<Plug>(coc-codeaction-line)* Get and run code action(s) for current line.

        *<Plug>(coc-codeaction-cursor)* Get and run code action(s) using empty range
        at current cursor.

        *<Plug>(coc-codeaction-selected)* Get and run code action(s) with the selected
        region.  Works on both |visual-mode| and |normal-mode|.

        *<Plug>(coc-openlink)* Open link under cursor by use |CocAction('openlink')|.

        *<Plug>(coc-codelens-action)* Do command from codeLens of current line.

        *<Plug>(coc-fix-current)* Try first quickfix action for diagnostics of current
        line.

        *<Plug>(coc-float-hide)* Hide all float windows/popups created by coc.nvim.

        *<Plug>(coc-float-jump)* Jump to first float window (neovim only), use
        |ctrl-w_p| for jump to previous window.

        *<Plug>(coc-range-select)*

            Select next selection range.
            Works on both |visual-mode| and |normal-mode|.

            Requires selection ranges feature of language server.

        *<Plug>(coc-funcobj-i)*

            Select inside function. Recommend mapping:
            Works on both |visual-mode| and |normal-mode|.


            xmap if <Plug>(coc-funcobj-i)
            omap if <Plug>(coc-funcobj-i)

            Requires 'textDocument.documentSymbol' support from the language
            server.

        *<Plug>(coc-funcobj-a)*

            Select around function.  Works on both |visual-mode| and
            |normal-mode|.  Recommended mapping:

            xmap af <Plug>(coc-funcobj-a)
            omap af <Plug>(coc-funcobj-a)

            Requires 'textDocument.documentSymbol' support from the language
            server.

        *<Plug>(coc-classobj-i)*

            Select inside class/struct/interface.  Works on both |visual-mode| and
            |normal-mode|.  Recommended mapping:

            xmap ic <Plug>(coc-classobj-i)
            omap ic <Plug>(coc-classobj-i)

            Requires 'textDocument.documentSymbol' support from the language
            server.

        *<Plug>(coc-classobj-a)*

            Select around class/struct/interface.  Works on both |visual-mode| and
            |normal-mode|.  Recommended mapping:

            xmap ac <Plug>(coc-classobj-a)
            omap ac <Plug>(coc-classobj-a)

            Requires 'textDocument.documentSymbol' support from the language
            server.


        *<Plug>(coc-cursors-operator)* Add text to cursors session by motion object.

        *<Plug>(coc-cursors-word)* Add current word to cursors session.

        *<Plug>(coc-cursors-position)* Add current position as empty range to cursors
        session.

    Visual mode key-mappings:~

    *<Plug>(coc-range-select-backward)*

        Select previous selection range.

        Requires selection ranges feature of language server, like:
        coc-tsserver, coc-python

    *<Plug>(coc-cursors-range)* Add selection to cursors session.

==============================================================================
VARIABLES						*coc-variables*

    Buffer variables~

        b:coc_enabled						*b:coc_enabled*  *coc-buffer-variables*

            Set to `0` on buffer create if you don't want coc.nvim receive content
            from buffer. Normally used with |BufAdd| autocmd, example:

            " Disable file with size > 1MB
            autocmd BufAdd * if getfsize(expand('<afile>')) > 1024*1024 |
                        \ let b:coc_enabled=0 |
                        \ endif

        b:coc_root_patterns					*b:coc_root_patterns*

            Root patterns used for resolving workspaceFolder for
            the current file, will be used instead of
            `"coc.preferences.rootPatterns"` setting. Example:


            autocmd FileType python let b:coc_root_patterns =
                        \ ['.git', '.env']


        b:coc_suggest_disable					*b:coc_suggest_disable*

            Disable completion support of current buffer. Example:


            " Disable completion for python
            autocmd FileType python let b:coc_suggest_disable = 1

        b:coc_disabled_sources 					*b:coc_disabled_sources*

            Disabled completion sources of current buffer. Example:

            let b:coc_disabled_sources = ['around', 'buffer', 'file']

        b:coc_diagnostic_disable				*b:coc_diagnostic_disable*

            Disable diagnostic support of current buffer.

        b:coc_suggest_blacklist                 	        *b:coc_suggest_blacklist*

            List of input words for which completion should not be triggered.
            Example:


            " Disable completion for 'end' in Lua files
            autocmd FileType lua let b:coc_suggest_blacklist = ["end"]

        b:coc_additional_keywords				*b:coc_additional_keywords*

            Addition keyword characters for generate keywords. Example:


            " Add keyword characters for CSS
            autocmd FileType css let b:coc_additional_keywords = ["-"]

        b:coc_trim_trailing_whitespace				*b:coc_trim_trailing_whitespace*

            Trim trailing whitespace on a line, default `0`.
            Use by "FormattingOptions" send to the server.

        b:coc_trim_final_newlines 				*b:coc_trim_final_newlines*

            Trim all newlines after the final newline at the end of the file.
            Use by "FormattingOptions" send to the server.

            Other buffer options that affect document format: 'eol', 'shiftwidth'
            and 'expandtab'.

            Language server may not respect format options.



    Global variables~
            *coc-global-variables*
        g:coc_disable_startup_warning 				*g:coc_disable_startup_warning*

            Disable possible warning on startup for old vim/node version.

            Default: 0

        g:coc_disable_uncaught_error 				*g:coc_disable_uncaught_error*

            Disable uncaught error messages from node process of coc.nvim.

            Default: 0

        g:coc_text_prop_offset 					*g:coc_text_prop_offset*

            Start |textprop| id offset of highlight namespaces on vim, change to
            other value to avoid conflict.

            Default: 1000

        g:coc_channel_timeout					*g:coc_channel_timeout*

            Channel timeout in seconds for request to node client.

            Default: 30

        g:coc_disable_transparent_cursor			*g:coc_disable_transparent_cursor*

            Disable transparent cursor when CocList is activated.
            Set it to `1` if you have issue with transparent
            cursor.

            Default: 0

        g:coc_start_at_startup					*g:coc_start_at_startup*

            Start coc service on startup, use |CocStart| to start server when you
            set it to 0.

            Default: 1

        g:coc_global_extensions					*g:coc_global_extensions*

            Global extension names to install when they aren't installed.

            let g:coc_global_extensions = ['coc-json', 'coc-git']

            Coc.nvim will try to install extensions that are not installed
            in this list after initialization.

        g:coc_uri_prefix_replace_patterns			*g:coc_uri_prefix_replace_patterns*

            This map defines URI prefix replacements. This is useful in the case
            that an LSP requires code to adhere to a particular directory
            structure. For example, `/Users/myUser/workspace` can be mapped to
            `/home/myUser/workspace`.

            let g:coc_uri_prefix_replace_patterns = {'/Users': '/home'}

        g:coc_enable_locationlist				*g:coc_enable_locationlist*

            Use location list of |CocList| when jump to locations.

            Set it to 0 when you need customize behavior of location jump by use
            |CocLocationsChange| and |g:coc_jump_locations|

            If you want use vim's quickfix list instead, add
            `"coc.preferences.useQuickfixForLocations": true` in your
            configuration file, this configuration would be ignored and no autocmd
            triggered.

            Default: 1

        g:coc_snippet_next					*g:coc_snippet_next*

            Trigger key for going to the next snippet position, applied in insert
            and select mode.

            Only works when snippet session is activated.

            Default: <C-j>

        g:coc_snippet_prev					*g:coc_snippet_prev*

            Trigger key for going to the previous snippet position, applied in
            insert and select mode.

            Only works when snippet session is activated.

            Default: <C-k>

        g:coc_filetype_map					*g:coc_filetype_map*

            Map for document filetypes so the server could handle current document
            as another filetype, example:


            let g:coc_filetype_map = {
                \ 'html.swig': 'html',
                \ 'wxss': 'css',
                \ }

            Default: {}

            See |coc-document-filetype| for details.

        g:coc_selectmode_mapping				*g:coc_selectmode_mapping*

            Add key mappings for making snippet select mode easier.


            snoremap <silent> <BS> <c-g>c
            snoremap <silent> <DEL> <c-g>c
            snoremap <silent> <c-h> <c-g>c
            snoremap <c-r> <c-g>"_c<c-r>

            Default: 1

        g:coc_node_path						*g:coc_node_path*

            Path to node executable to start coc service, example:


            let g:coc_node_path = '/usr/local/opt/node@12/bin/node'

            Use this when coc has problems with your system node,

            You can use `~` as home directory.

        g:coc_node_args						*g:coc_node_args*

            Arguments passed to node when starting coc service from source code.

            Useful for starting coc in debug mode, example:


            let g:coc_node_args = ['--nolazy', '--inspect-brk=6045']

            Default: []

        g:coc_status_error_sign					*g:coc_status_error_sign*

            Error character used for statusline, default: `E`

        g:coc_status_warning_sign				*g:coc_status_warning_sign*

            Warning character used for statusline, default: `W`

        g:coc_quickfix_open_command				*g:coc_quickfix_open_command*

            Command used for open quickfix list.  To jump fist position after
            quickfix list opend, you can use:

            let g:coc_quickfix_open_command = 'copen|cfirst'

            Default: |copen|

        g:node_client_debug					*g:node_client_debug*

            Enable debug mode of node client for check rpc messages between vim
            and coc.nvim.  Use environment variable $NODE_CLIENT_LOG_FILE to set
            the log file or get the log file after coc.nvim started.
            To open the log file, use command:


            :call coc#client#open_log()

            Default: `0`

        g:coc_config_home					*g:coc_config_home*

            Configure the directory which will be used to look for
            user's `coc-settings.json`, default:

            Windows: `~/AppData/Local/nvim`
            Other: `~/.config/nvim`

        g:coc_data_home						*g:coc_data_home*

            Configure the directory which will be used to for data
            files(extensions, MRU and so on), default:

            Windows: `~/AppData/Local/coc`
            Other: `~/.config/coc`

        g:coc_terminal_height					*g:coc_terminal_height*

            Height of terminal window, default `8`.

        g:coc_markdown_disabled_languages  			*g:coc_markdown_disabled_languages*

            Filetype list that should be disabled for highlight in markdown block,
            Example:


            let g:coc_markdown_disabled_languages = ['html']

        g:coc_highlight_maximum_count 				*g:coc_highlight_maximum_count*

            When highlight items exceed maximum count, highlight items will be
            grouped and added by using |timer_start| for better user experience.

            Default `100`

        g:coc_default_semantic_highlight_groups 		*g:coc_default_semantic_highlight_groups*

            Create default semantic highlight groups for |coc-semantic-highlights|

            Default: `1`

        g:coc_max_treeview_width 				*g:coc_max_treeview_width*

            Maximum width of tree view when adjusted by auto width.

            Default: `40`

        g:coc_borderchars 					*g:coc_borderchars*

            Border characters used by border window, default to:

            ['─', '│', '─', '│', '┌', '┐', '┘', '└']

            You may need special font like Nerd font to show them.

        g:coc_border_joinchars 					*g:coc_border_joinchars*

            Border join characters used by float window/popup, default to:

            ['┬', '┤', '┴', '├']

            You may need special font like Nerd font to show them.

        g:coc_prompt_win_width 					*g:coc_prompt_win_width*

            Width of input prompt window, default `32`.

                                    *g:coc_notify*
        g:coc_notify_error_icon 				*g:coc_notify_error_icon*

            Error icon for notification, default to: 

        g:coc_notify_warning_icon 				*g:coc_notify_warning_icon*

            Warning icon for notification, default to: ⚠

        g:coc_notify_info_icon 					*g:coc_notify_info_icon*

            Info icon for notification, default to: 



    Some variables are provided by coc.nvim~


        g:WorkspaceFolders					*g:WorkspaceFolders*

            Current workspace folders, used for restoring from a session file, add
            `set sessionoptions+=globals` to vimrc for restoring globals on
            session load.

        g:coc_jump_locations					*g:coc_jump_locations*

            This variable would be set to jump locations when the
            |CocLocationsChange| autocmd is fired.

            Each location item contains:

            'filename': full file path.
            'lnum': line number (1 based).
            'col': column number(1 based).
            'text':  line content of location.

        g:coc_process_pid					*g:coc_process_pid*

            Process pid of coc.nvim service. If your vim doesn't kill coc.nvim
            process on exit, use:

            autocmd VimLeavePre * if get(g:, 'coc_process_pid', 0)
                \	| call system('kill -9 '.g:coc_process_pid) | endif

            in your vimrc.

        g:coc_service_initialized	 			*g:coc_service_initialized*

            Is `1` when coc.nvim initialized, used with autocmd |CocNvimInit|.

        g:coc_status						*g:coc_status*

            Status string contributed by coc.nvim and extensions, used for status
            line.

        g:coc_last_float_win					*g:coc_last_float_win*

            Window id of latest created float/popup window.

        g:coc_last_hover_message				*g:coc_last_hover_message*

            Last message echoed from `doHover`, can be used in statusline.

            Not used when floating or preview window used for `doHover`.

        b:coc_snippet_active					*b:coc_snippet_active*

            Is `1` when snippet session is activated, use |coc#jumpable| to check
            if it's possible to jump placeholder.

        b:coc_diagnostic_info					*b:coc_diagnostic_info*

            Diagnostic information of current buffer, the format would look like:

            `{'error': 0, 'warning': 0, 'information': 0, 'hint':0}`

            can be used to customize statusline. See |coc-status|.

        b:coc_current_function					*b:coc_current_function*

            Function string that current cursor in.

            Set `"coc.preferences.currentFunctionSymbolAutoUpdate": true`
            in coc-settings.json to update it on CursorHold.

        b:coc_cursors_activated					*b:coc_cursors_activated*

            Use expression `get(b:, 'coc_cursors_activated',0)` to check if
            cursors session is activated for current buffer.

=================================
FUNCTIONS						*coc-functions*


    Coc functions are normally used by
    user defined command/keymap or
    other plugins.

    Some functions only work after the coc service has been initialized.

    To run a function on startup, use an autocmd like:

        autocmd User CocNvimInit call CocAction('runCommand',   'tsserver.watchBuild')

    ----------------

    coc#start([{option}]) 					*coc#start()*

        Start completion with optional {option}.  Option could contains:

            - `source` specific completion source name.

        Example:


        inoremap <silent> <C-w> <C-R>=coc#start({'source': 'word'})<CR>

        Use `:CocList sources` to get available sources.

    coc#refresh()						*coc#refresh()*

        Start or refresh completion at current cursor position, bind this to
        'imap' to trigger completion, example:


        inoremap <silent><expr> <c-space> coc#refresh()

    coc#_select_confirm()					*coc#_select_confirm()*

        Select first completion item if no completion item is selected, then
        confirm the completion.

    coc#config({section}, {value})				*coc#config()*

        Change user configuration, overwrite configurations from
        user config file and default values. Example:


        call coc#config('coc.preferences', {
            \ 'timeout': 1000,
            \})
        call coc#config('languageserver', {
            \ 'ccls': {
            \   "command": "ccls",
            \   "trace.server": "verbose",
            \   "filetypes": ["c", "cpp", "objc", "objcpp"]
            \ }
            \})


        This function can be called multiple times.
        This function can be called before coc.nvim started.
        This function can work alongside the user configuration file,
        but it's not recommended to use both.

    coc#add_extension({name}, ...)				*coc#add_extension()*

        Deprecated function for install extensions not exists.
        Use |g:coc_global_extensions| variable instead.

        Example:


        call coc#add_extension('coc-json', 'coc-tsserver', 'coc-rls')

        This function can be called before service initialized.
        This function can be called multiple times.

    coc#add_command({id}, {command}, [{title}])		*coc#add_command()*

        Add custom Vim command to commands list opened by
        `:CocList commands` .

        Example:


        call coc#add_command('mundoToggle', 'MundoToggle',
            \ 'toggle mundo window')

    coc#expandable()					*coc#expandable()*

        Check if a snippet is expandable at the current position.
        Requires `coc-snippets` extension installed.

    coc#jumpable()						*coc#jumpable()*

        Check if a snippet is jumpable at the current position.

    coc#expandableOrJumpable()				*coc#expandableOrJumpable()*

        Check if a snippet is expandable or jumpable at the current position.
        Requires `coc-snippets` extension installed.

    coc#on_enter()						*coc#on_enter()*

        Notify coc.nvim that `<enter>` has been pressed.

        Used for the format on type and improvement of brackets, example:


        " Confirm the completion when popupmenu is visible, insert <CR> and
        " notify coc.nvim otherwise.
        inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                                    \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

        Note：to enable format on type, add ` "coc.preferences.formatOnType": true`
        in your settings file.

    coc#status()						*coc#status()*

        Return a status string that can be used in the status line, the status
        includes diagnostic information from `b:coc_diagnostic_info` and
        extension contributed statuses from `g:coc_status`. For statusline
        integration, see |coc-status|

    coc#util#api_version() 					*coc#util#api_version()*

        Get coc.nvim's vim API version number, start from `1`.

    coc#util#job_command()					*coc#util#job_command()*

        Get the job command used for starting the coc service.

    coc#util#get_config_home()				*coc#util#get_config_home()*

        Get the config directory that contains the user's coc-settings.json.

    coc#util#get_data_home()				*coc#util#get_data_home()*

        Get `coc` data directory.

    coc#util#extension_root()				*coc#util#extension_root()*

        Return extensions root of coc.nvim.

    coc#util#rebuild()					*coc#util#rebuild()*

        Run `npm rebuild` for all coc extensions.

    coc#util#root_patterns()				*coc#util#root_patterns()*

        Get root patterns used for current document.

        Result could be something like:


        {'global': ['.git', '.hg', '.projections.json'], 'buffer': [], 'server': v:null}

    coc#util#get_config({key})				*coc#util#get_config()*

        Get configuration (mostly defined in coc-settings.json)	by {key},
        example:


        :echo coc#util#get_config('coc.preferences')

    coc#snippet#next() 					*coc#snippet#next()*

        Jump to next placeholder, does nothing when |coc#jumpable| is 0.

    coc#snippet#prev() 					*coc#snippet#prev()*

        Jump to previous placeholder, does nothing when |coc#jumpable| is 0.

                                *coc#pum*
    coc#pum#visible() 					*coc#pum#visible()*

        Check if customized popupmenu is visible.

    coc#pum#next({insert}) 					*coc#pum#next()*

        Select next item of customized popupmenu, insert word when {insert} is
        truth value.

    coc#pum#prev({insert}) 					*coc#pum#prev()*

        Select previous item of customized popupmenu, insert word when {insert}
        is truth value.

    coc#pum#stop() 						*coc#pum#stop()*

        Close the customized popupmenu, works like <C-x><C-z> of vim.
        Return <Ignore>

    coc#pum#cancel() 					*coc#pum#cancel()*

        Cancel the customized popupmenu and revert trigger input, like <C-e>
        of vim. Return empty string.

    coc#pum#confirm() 					*coc#pum#confirm()*

        Confirm completion and close the customized pum, like <C-y> of vim.
        Return empty string.

    coc#pum#info() 						*coc#pum#info()*

        Return information of the customized popupmenu, should only be used
        when |coc#pum#visible()| is 1.

        Result contains:
            index 		Current select item index, 0 based.
            scrollbar 	Non-zero if a scrollbar is displayed.
            row 		Screen row count, 0 based.
            col 		Screen column count, 0 based.
            width 		Width of pum, including padding and border.
            height 		Height of pum, including padding and border.
            size 		Count of displayed complete items.
            inserted 	Is |v:true| when there is item inserted.

    coc#pum#select({index}, {insert}, {confirm}) 		*coc#pum#select()*

        Selects an item in the completion popupmenu.
        Return empty string.

        Parameters:~
            {index} 	Index (zero-based) of the item to select.
            {insert} 	Whether the selection should be inserted
                    in the buffer.
            {confirm} 	Confirm the completion and dismiss the
                    popupmenu, implies `insert`.

    coc#pum#insert() 					*coc#pum#insert()*

        Insert word of current selected item and finish completion.
        Timer is used to make it works as rhs of key-mappings.

    coc#pum#scroll({forward}) 				*coc#pum#scroll()*

        Scroll the popupmenu forward or backward by page.
        Timer is used to make it works as rhs of key-mappings.
        Return empty string.

        Parameters:~
            {forward} 	Scroll forward when none zero.

                                *coc#notify*
    coc#notify#close_all()					*coc#notify#close_all()*

        Close all notification windows.

    coc#notify#do_action([{winid}]) 			*coc#notify#do_action()*

        Invoke action for all notification windows, or particular window with
        winid.

    coc#notify#copy() 					*coc#notify#copy()*

        Copy all content from notifications to system clipboard.

    coc#notify#show_sources() 				*coc#notify#show_sources()*

        Show source name (extension name) in notification windows.

    coc#notify#keep() 					*coc#notify#keep()*

        Stop auto hide timer of notification windows.

    coc#float#has_float([{all}]) 				*coc#float#has_float()*

        Check if float window/popup exists, check coc.nvim's float
        window/popup by default.

    coc#float#close_all([{all}])				*coc#float#close_all()*

        Close all float windows/popups created by coc.nvim, set {all} to `1`
        for all float window/popups.

    coc#float#close({winid}) 				*coc#float#close()*

        Close float window/popup with {winid}.

    coc#float#has_scroll() 					*coc#float#has_scroll()*

        Return `1` when there is scrollable float window/popup created by
        coc.nvim.

        Example key-mappings:

        if has('nvim-0.4.0') || has('patch-8.2.0750')
        nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
        nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
        inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
        inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
        vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
        vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
        endif

    coc#float#scroll({forward}, [{amount}])			*coc#float#scroll()*

        Scroll all scrollable float windows/popups, scroll backward when
        {forward} is not `1`. {amount} could be number or full page when
        omitted.

        This function requires nvim >= 0.4.0 or vim >= 8.2.750 to work.


    CocRequest({id}, {method}, [{params}])			*CocRequest()*

        Send a request to language client of {id} with {method} and optional
        {params}. Example:


        call CocRequest('tslint', 'textDocument/tslint/allFixes',
            \  {'textDocument': {'uri': 'file:///tmp'}})

        Vim error will be raised if the response contains an error.

                                *CocRequestAsync()*

    CocRequestAsync({id}, {method}, [{params}, [{callback}]])

        Send async request to remote language server.
        {callback} function is called with error and response.

    CocNotify({id}, {method}, [{params}])			*CocNotify()*

        Send notification to remote language server, example:

        call CocNotify('ccls', '$ccls/reload')

                                *CocRegistNotification()*

    CocRegistNotification({id}, {method}, {callback})

        Register notification callback for specified client {id} and {method},
        example:


        autocmd User CocNvimInit call CocRegistNotification('ccls',
            \ '$ccls/publishSemanticHighlight', function('s:Handler'))

        {callback} is called with single param as notification result.

        When register notification with same {id} and {method}, only the
        later registered would work.

                                *CocLocations()*

    CocLocations({id}, {method}, [{params}, {openCommand}])

        Send location request to language client of {id} with
        {method} and optional {params}. e.g.:


        call CocLocations('ccls', '$ccls/call',  {'callee': v:true})

        call CocLocations('ccls', '$ccls/call',  {}, 'vsplit')

        {openCommand}: optional command to open buffer, default to
        `coc.preferences.jumpCommand` , |:edit| by default.  When it's
        `v:false` locations list would always used.

                                *CocLocationsAsync()*

    CocLocationsAsync({id}, {method}, [{params}, {openCommand}])

        Same as |CocLocations()|, but send notification to server instead
        of request.


    CocHasProvider({feature})				*CocHasProvider()*

        Check if provider exists for specified feature of current buffer.
        Supported features:

        `rename` `onTypeEdit` `documentLink` `documentColor` `foldingRange`
        `format` `codeAction` `workspaceSymbols` `formatRange` `hover`
        `signature` `documentSymbol` `documentHighlight` `definition`
        `declaration` `typeDefinition` `reference` `implementation` `codeLens`
        `selectionRange`

    CocTagFunc({pattern}, {flags}, {info})			*CocTagFunc()*

        Used for vim's 'tagfunc' option, to make tag search by |ctrl-]| use
        coc.nvim as provider, tag search would be performed when no result
        from coc.nvim.

        Make sure your vim support 'tagfunc' by

        :echo exists('&tagfunc')

                                *coc-actions*

    CocAction({action}, [...{args}])			*CocAction()*

        Run {action} of coc with optional extra {args}.

        Checkout |coc-actions| for available actions.

        It's recommended to use |CocActionAsync()| unless you have to
        block your vim.

                                *CocActionAsync()*

    CocActionAsync({action}, [...{args}, [{callback}]])

        Call CocAction by send notification to server of coc.nvim.

        Optional callback is called with `error` as the first argument and
        `response` as the second argument.

        Checkout |coc-actions| for available actions.


================================================

Acceptable {action} names for |CocAction()| and |CocActionAsync()|

    "ensureDocument" 					*CocAction('ensureDocument')*

        Ensure current document is attached to coc.nvim
        |coc-document-attached|, should be used when you need invoke action of
        current document on buffer create.

        Return |v:false| when document can't be attached.

    "diagnosticList"					*CocAction('diagnosticList')*

        Get all diagnostic items of the current Neovim session.

    "diagnosticInfo"					*CocAction('diagnosticInfo')*

        Show diagnostic message at the current position, do not truncate.

    "diagnosticToggle" [{enable}]	 			*CocAction('diagnosticToggle')*

        Enable/disable diagnostics on the fly, not work when `displayByAle` is
        enabled. You can toggle by specifying {enable}. {enable} can be 0 or 1

    "diagnosticPreview"					*CocAction('diagnosticPreview')*

        Show diagnostics under current cursor in preview window.

    "diagnosticRefresh" [{bufnr}] 				*CocAction('diagnosticRefresh')*

        Force refresh diagnostics for special buffer with {bufnr} or all buffers
        when {bufnr} doesn't exist, returns `v:null` before diagnostics are shown.

        Will refresh in any mode.

        Useful when `diagnostic.autoRefresh` is `false`.

    "refreshSource" [{source}]				*CocAction('refreshSource')*

        refresh all sources or a source with a name of {source}.

    "sourceStat"						*CocAction('sourceStat')*

        get the list of completion source stats for the current buffer.

    "toggleSource" {source}					*CocAction('toggleSource')*

        enable/disable {source}.

    "definitions" 						*CocAction('definitions')*

        Get definition locations of symbol under cursor.
        Return LSP `Location[]`

    "declarations" 						*CocAction('declarations')*

        Get declaration location(s) of symbol under cursor.
        Return LSP `Location | Location[] | LocationLink[]`

    "implementations" 					*CocAction('implementations')*

        Get implementation locations of symbol under cursor.
        Return LSP `Location[]`

    "typeDefinitions" 					*CocAction('typeDefinitions')*

        Get type definition locations of symbol under cursor.
        Return LSP `Location[]`

    "references" [{excludeDeclaration}] 			*CocAction('references')*

        Get references location list of symbol under cursor.

        {excludeDeclaration}: exclude declaration locations when not zero.

        Return LSP `Location[]`

    "jumpDefinition" [{openCommand}]			*CocAction('jumpDefinition')*

        jump to definition locations of the current symbol.
        Return `v:false` when location not found.

        |coc-list-location| is used when more than one position is available,
        for custom location list, use variable: |g:coc_enable_locationlist|.

        To always use |coc-list-location|| for locations, use `v:false` for
        {openCommand}.

        {openCommand}: optional command to open buffer, default to
        `coc.preferences.jumpCommand` in `coc-settings.json`

    "jumpDeclaration" [{openCommand}]			*CocAction('jumpDeclaration')*

        jump to declaration locations of the current symbol.
        Return `v:false` when location not found.

        same behavior as "jumpDefinition".

        When {openCommand} is `v:false`, location list would be always used.

    "jumpImplementation" [{openCommand}]			*CocAction('jumpImplementation')*

        Jump to implementation locations of the current symbol.
        Return `v:false` when location not found.

        same behavior as "jumpDefinition"

    "jumpTypeDefinition" [{openCommand}]			*CocAction('jumpTypeDefinition')*

        Jump to type definition locations of the current symbol.
        Return `v:false` when location not found.

        same behavior as "jumpDefinition"

    "jumpReferences" [{openCommand}]			*CocAction('jumpReferences')*

        Jump to references locations of the current symbol, use
        |CocAction('jumpUsed')| to exclude declaration locations.

        Return `v:false` when location not found.

        same behavior as "jumpDefinition"

    "jumpUsed" [{openCommand}] 				*CocAction('jumpUsed')*

        Jump references locations without declarations.

        same behavior as "jumpDefinition"

    "getHover"						*CocAction('getHover')*

        Get documentation text array on current position, returns array of
        string.

    "doHover" [{hoverTarget}]				*CocAction('doHover')*


        Show documentation of
        current symbol,
        return `v:false` when hover not found.

        {hoverTarget}:
            optional specification for where to show hover info,
            defaults to `coc.preferences.hoverTarget` in `coc-settings.json`.
            Valid options: ["preview", "echo", "float"]

    "definitionHover" [{hoverTarget}]
            *CocAction('definitionHover')*
        Same as |CocAction('doHover')|,
        but includes definition contents from  definition provider when possible.

    "showSignatureHelp"					*CocAction('showSignatureHelp')*

        Echo signature help of current function, return `v:false` when
        signature not found.  You may want to set up an autocmd like this:


        autocmd User CocJumpPlaceholder call
                    \ CocActionAsync('showSignatureHelp')

    "getCurrentFunctionSymbol"				*CocAction('getCurrentFunctionSymbol')*

        Return the function string that current cursor in.

    "documentSymbols" [{bufnr}]				*CocAction('documentSymbols')*

        Get a list of symbols of current buffer or specific {bufnr}.

    "rename"						*CocAction('rename')*

        Rename the symbol under the cursor position, user will be prompted for
        a new name.

        Coc.nvim supports rename for disk files, but your language server
        may not.

    "refactor"						*CocAction('refactor')*

        Open refactor windows with current symbol as activated cursor ranges.
        Check |coc-config-cursors| and |coc-config-refactor| for related
        configuration.

        Use <CR> to open buffer at current position in split window.
        Use <Tab> to show action menu which have tab open and remove actions.

    "format"						*CocAction('format')*

        Format current buffer using the language server.
        Return `v:false` when format failed.

    "formatSelected" [{mode}]				*CocAction('formatSelected')*

        Format the selected range, {mode} should be one of visual mode: `v` ,
        `V`, `char`, `line`.

        When {mode} is omitted, it should be called using |formatexpr|.


    "selectionRanges"					*CocAction('selectionRanges')*

        Get selection ranges of current position from language server.

    "services"						*CocAction('services')*

        Get an information list for all services.

    "toggleService" {serviceId}				*CocAction('toggleService')*

        Start or stop a service.

    "codeAction" [{mode}] [{only}]				*CocAction('codeAction')*

        Prompt for a code action and do it.

        {mode} could be `currline` or `cursor` or result of |visualmode()|,
        current buffer range is used when it's empty string.

        {only} can be title of a codeAction or list of CodeActionKind.

    "codeActionRange" {start} {end} [{kind}]		*CocAction('codeActionRange')*

        Run code action for range.

        {start} 	Start line number of range.
        {end} 		End line number of range.
        {kind} 		Code action kind, see |CocAction('codeActions')| for available
                action kind.

        Can be used to create commands like:


        command! -nargs=* -range CocAction :call CocActionAsync('codeActionRange', <line1>, <line2>, <f-args>)
        command! -nargs=* -range CocFix    :call CocActionAsync('codeActionRange', <line1>, <line2>, 'quickfix')

    "codeLensAction"					*CocAction('codeLensAction')*

        Invoke the command for codeLens of current line (or the line that
        contains codeLens just above). Prompt would be shown when multiple
        actions are available.

    "commands"						*CocAction('commands')*

        Get a list of available service commands for the current buffer.

    "runCommand" [{name}] [...{args}]			*CocAction('runCommand')*

        Run a global command provided by the language server. If {name} is not
        provided, a prompt with a list of commands is shown to be selected.

        {args} are passed as arguments of command.

        You can bind your custom command like so:


        command! -nargs=0 OrganizeImport
            \ :call CocActionAsync('runCommand', 'tsserver.organizeImports')

    "fold" {{kind}}						*CocAction('fold')*

        Fold the current buffer, optionally use {kind} for filtering folds,
        {kind} could be either 'comment', 'imports' or 'region'

        Return `v:false` when failed.

    "highlight"						*CocAction('highlight')*

        Highlight the symbols under the cursor.

    "openLink" [{command}]					*CocAction('openlink')*

        Open a link under the cursor with {command}.
        {command} default to `edit`.

        File and URL links are supported, return `v:false` when failed.

        URI under cursor is searched when no link returned from documentLink
        provider.

    "extensionStats"					*CocAction('extensionStats')*

        Get all extension states as a list. Including `id`, `root` and
        `state`.

        State could be `disabled`, `activated` and `loaded`.

    "toggleExtension" {id}					*CocAction('toggleExtension')*

        Enable/disable an extension.

    "uninstallExtension" {id}				*CocAction('uninstallExtension')*

        Uninstall an extension.

    "reloadExtension" {id}					*CocAction('reloadExtension')*

        Reload an activated extension.

    "activeExtension" {id}					*CocAction('activeExtension')*

        Activate extension of {id}.

    "deactivateExtension" {id}				*CocAction('deactivateExtension')*

        Deactivate extension of {id}.

    "pickColor"						*CocAction('pickColor')*

        Change the color at the current cursor position, requires
        `documentColor` provider |CocHasProvider|.

        Only works on mac or when you have python support on Vim and
        have the GTK module installed.

    "colorPresentation"					*CocAction('colorPresentation')*

        Change the color presentation at the current color position, requires
        `documentColor` provider |CocHasProvider|.

    "codeActions" [{mode}] [{only}]				*CocAction('codeActions')*

        Get codeActions list of current document.

        {mode} can be result of |visualmode()| for visual selected
        range.  When it's falsy value, current file is used as range.

        {only} can be array of codeActionKind, possible values including:
        - 'refactor': Base kind for refactoring actions
        - 'quickfix': base kind for quickfix actions
        - 'refactor.extract': Base kind for refactoring extraction actions
        - 'refactor.inline': Base kind for refactoring inline actions
        - 'refactor.rewrite': Base kind for refactoring rewrite actions
        - 'source': Base kind for source actions
        - 'source.organizeImports': Base kind for an organize imports source
        action
        - 'source.fixAll': Base kind for auto-fix source actions

        {only} can also be string, which means filter by title of codeAction.

    "organizeImport" 					*CocAction('organizeImport')*

        Run organize import codeAction for current buffer.
        Show warning when codeAction not found.

    "fixAll" 						*CocAction('fixAll')*

        Run fixAll codeAction for current buffer.
        Show warning when codeAction not found.


    "quickfixes" [{visualmode}]				*CocAction('quickfixes')*

        Get quickfix codeActions of current buffer.

        Add {visualmode} as second argument get quickfix actions with range of
        latest |visualmode()|

    "doCodeAction" {codeAction}				*CocAction('doCodeAction')*

        Do a codeAction.

    "doQuickfix"						*CocAction('doQuickfix')*

        Do the first preferred quickfix action on current line.

        Throw error when no quickfix action found.

    "addRanges" {ranges}					*CocAction('addRanges')*

        Ranges must be provided as array of range type: https://git.io/fjiEG

    "getWordEdit"						*CocAction('getWordEdit')*

        Get workspaceEdit of current word, language server used when possible,
        extract word from current buffer as fallback.

    "getWorkspaceSymbols" {input}				*CocAction('getWorkspaceSymbols')*

        Get workspace symbols from {input}.

    "resolveWorkspaceSymbol" {symbol} 			*CocAction('resolveWorkspaceSymbol')*

        Resolve location for workspace {symbol}.

    "diagnosticToggleBuffer" [{bufnr}] [{enable}] 		*CocAction('diagnosticToggleBuffer')*

        Toggle diagnostics for specific buffer, current buffer is used when
        {bufnr} not provided. 0 for current buffer
        You can toggle by specifying {enable}. {enable} can be 0 or 1

        This will only affect diagnostics shown in the UI, list of all
        diagnostics won't change.

    "showOutline" [{keep}]					*CocAction('showOutline')*

        Show |coc-outline| for current buffer. Does nothing when outline
        window already shown for current buffer.

        {keep} override `"outline.keepWindow"` configuration when specified.
        Could be 0 or 1.

        Returns after window is shown (document symbol request is still in
        progress).

    "hideOutline" 						*CocAction('hideOutline')*

        Close |coc-outline| on current tab.  Throws vim error when it can't
        be closed by vim.

    "incomingCalls" [{CallHierarchyItem}] 			*CocAction('incomingCalls')*

        Retrieve incoming calls from {CallHierarchyItem} or current position
        when not provided.

    "outgoingCalls" [{CallHierarchyItem}] 			*CocAction('outgoingCalls')*

        Retrieve outgoing calls from {CallHierarchyItem} or current position
        when not provided.

    "showIncomingCalls"  					*CocAction('showIncomingCalls')*

        Show incoming calls of current function with |coc-tree|, see
        |coc-callHierarchy|

    "showOutgoingCalls"  					*CocAction('showOutgoingCalls')*

        Show outgoing calls of current function with |coc-tree|.

    "semanticHighlight" 					*CocAction('semanticHighlight')*

        Request semantic tokens highlight for current buffer.

    "inspectSemanticToken" 					*CocAction('inspectSemanticToken')*

        Inspect semantic token information at cursor position.

    "rangeSelect" {visualmode} {forward} 		 	*CocAction('rangeSelect')*

        Visual select previous or next code range, requires `selectionRange`
        provider.

        {visualmode} should be result of {visualmode} or "" for current cursor
        position.
        {forward} select backward when it's falsy value.

=================================================
COMMANDS						*coc-commands*

    :CocStart						*:CocStart*

        Start the coc.nvim server, do nothing if it's already started.

    :CocRestart						*:CocRestart*

        Restart coc.nvim service.

        Use this command when you want coc to start all over again.

    :CocDisable						*:CocDisable*

        Disable handling vim events.

    :CocEnable						*:CocEnable*

        Enable handling vim events.

    :CocConfig						*:CocConfig*

        Edit the user config file `.vim/coc-settings.json` in
        |coc#util#get_config_home()|

    :CocLocalConfig						*:CocLocalConfig*

        Edit or create `.vim/coc-settings.json` in current workspace folder.

    :CocInstall [{option}] {name} ...			*:CocInstall*

        Install one or more coc extensions.

        {option}: could be `-sync` for use blocked process to download instead
        of terminal.

        Examples:


        " Install latest coc-omni
        :CocInstall coc-omni
        " Install coc-omni 1.0.0
        :CocInstall coc-omni@1.0.0
        " Install snippet extension from github
        :CocInstall https://github.com/dsznajder/vscode-es7-javascript-react-snippets

    :CocUninstall {name}					*:CocUninstall*

        Uninstall an extension, use <tab> to complete the extension
        name.

    :CocUpdate						*:CocUpdate*

        Update all coc extensions to the latest version.

    :CocUpdateSync						*:CocUpdateSync*

        Block version of update coc extensions.

    :CocRebuild						*:CocRebuild*

        Run `npm rebuild` for coc extensions.

        May be required when environment nodejs get upgraded.

    :CocCommand {name} [{args}] ... 			*:CocCommand*

        Run a command contributed by extensions, use `<tab>` for name
        completion.

    :CocOpenLog						*:CocOpenLog*

        Open log file of coc.nvim.

        Use environmental variable `NVIM_COC_LOG_FILE` for fixed log file.
        The log would be cleared when coc.nvim started.

        Use environment variable `NVIM_COC_LOG_LEVEL` to change log level
        (default 'info', could be 'all', 'trace', 'debug', 'info',
        'warn', 'error', 'off').
        Use shell command:


        export NVIM_COC_LOG_LEVEL=debug

        or add:


        let $NVIM_COC_LOG_LEVEL='debug'

        to the beginning of your `.vimrc`

    :CocInfo						*:CocInfo*

        Show version and log information in a split window, useful for
        submitting a bug report.

    :CocDiagnostics	[height] 				*:CocDiagnostics*

        Open vim's |location-list| with diagnostics of current buffer.

    :CocSearch 						*:CocSearch*

        Perform search by ripgrep https://github.com/BurntSushi/ripgrep,
        refactor window would be opened.

        The search is performed on your files, so normally you should
        save your buffers before invoke this command.

        Common arguments for ripgrep:~

        `-e` `--regexp`: treat search pattern as regexp.
        `-F` `--fixed-strings`: treat search pattern as fixed string.
        `-L` `--follow`: follow symbolic links while traversing directories.
        `-g` `--glob` {GLOB}: Include or exclude files and directories for
        searching that match the given glob.
        `--hidden`: Search hidden files and directories.
        `--no-ignore-vcs`:  Don't respect version control ignore files
        (.gitignore, etc.).
        `--no-ignore`: Don't respect ignore files (.gitignore, .ignore, etc.).
        `-w` `--word-regexp`: Only show matches surrounded by word boundaries.
        `-S` `--smart-case`: Searches case insensitively if the pattern is all
        lowercase. Search case sensitively otherwise.
        `--no-config`: Never read configuration files.
        `-x` `--line-regexp`: Only show matches surrounded by line boundaries.

        Use `:man 1 rg` in your terminal for more details.

        By default, hidden files and directories are skipped.

        By default, vcs ignore files including `.gitignore` and
        `.ignore` are respected

        Escape arguments:~

        |<f-args>| is used to convert command line arguments to arguments of
        rg, which means you have to escape space for single argument. For
        example, if you want to search `import { Neovim` , you have to use:

        :CocSearch import\ \{\ Neovim

        The escape for `{` is required because rg use regexp be default, or:

        :CocSearch -F import\ {\ Neovim

        for strict match.

        Change and save:~

        Refactor session is started with searched patterns highlighted, just
        change the text and save refactor buffer to make changes across all
        related files. You can make any kind of changes, including add lines
        and remove lines.

    :CocWatch [extension] 					*:CocWatch*

        Watch loaded [extension] for reload on file change, use <tab> for
        complete extension id.

    :CocOutline 						*:CocOutline*

        Invoke |CocAction('showOutline')| by notification.

=======================
AUTOCMD							*coc-autocmds*  *CocLocationsChange*

    :autocmd User CocLocationsChange {command}

        For building a custom view of locations, set
        |g:coc_enable_locationlist| to 0 and use this autocmd with with
        |g:coc_jump_locations|

        For example, to disable auto preview of location list, use:

        let g:coc_enable_locationlist = 0
        autocmd User CocLocationsChange CocList --normal location

                                *CocNvimInit*
    :autocmd User CocNvimInit {command}

        Triggered after the coc services have started.

        If you want to trigger an action of coc after Vim has started, this
        autocmd should be used because coc is always started asynchronously.

                                *CocStatusChange*

    :autocmd User CocStatusChange {command}

        Triggered after `g:coc_status` changed, can be used for refresh
        statusline.

                                *CocDiagnosticChange*

    :autocmd User CocDiagnosticChange {command}

        Triggered after the diagnostic status has changed.

        Could be used for updating the statusline.

                                *CocJumpPlaceholder*

    :autocmd User CocJumpPlaceholder {command}

        Triggered after a jump to a placeholder. Can be used for
        showing signature help like:


        autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')

                                *CocOpenFloat*

    :autocmd User CocOpenFloat {command}

        Triggered when a floating window is opened.  The window is not
        focused, use |g:coc_last_float_win| to get window id.

                                *CocOpenFloatPrompt*

    :autocmd User CocOpenFloatPrompt {command}

        Triggered when a floating prompt window is opened (triggered after
        CocOpenFloat).

                                *CocTerminalOpen*
    :autocmd User CocTerminalOpen {command}

        Triggered when the terminal is shown, can be used for adjusting the
        window height.

================================================

HIGHLIGHTS						*coc-highlights*

    To customize a highlight, simply use |:highlight| command in your vimrc, like:

            " make error texts have a red color
            :highlight CocErrorHighlight ctermfg=Red  guifg=#ff0000


        User defined highlight commands should appear after the |:colorscheme| command and
        use |ColorScheme| autocmd to
            make sure customized highlights works after color scheme change.

    Markdown related~

        *CocBold*           for bold text.
        *CocItalic*         for italic text.
        *CocUnderline*      for underlined text.
        *CocStrikeThrough*  for strikethrough text, like usage of deprecated API.
        *CocMarkdownCode*   for inline code in markdown content.
        *CocMarkdownHeader* for markdown header in floating window/popup.
        *CocMarkdownLink*   for markdown link text in floating window/popup.

    Diagnostics related~
                                *coc-highlights-diagnostics*
        *CocFadeOut*                                  for faded out text, such as for highlighting unnecessary code.
        *CocErrorSign*                                for error signs.
        *CocWarningSign*                              for warning signs.
        *CocInfoSign*                                 for information signs.
        *CocHintSign*                                 for hint signs.
        *CocErrorVirtualText*                         for error virtual text.
        *CocWarningVirtualText*                       for warning virtual text.
        *CocInfoVirtualText*                          for information virtual text.
        *CocHintVirtualText*                          for hint virtual text.
        *CocErrorHighlight*                           for error code range.
        *CocWarningHighlight*                         for warning code range.
        *CocInfoHighlight*                            for information code range.
        *CocHintHighlight*                            for hint code range.
        *CocDeprecatedHighlight*                      for deprecated code range, links to  |CocStrikeThrough| by default.
        *CocUnusedHighlight*                          for unnecessary code range, links to |CocFadeOut| by  default.
        *CocErrorLine*   line highlight of sign which contains error.
        *CocWarningLine*
        *CocInfoLine*
        *CocHintLine*

        Highlight with higher priority would overwrite highlight with lower priority.
        The priority order:

            |CocUnusedHighlight| > |CocDeprecatedHighlight| > |CocErrorHighlight|
            > |CocWarningHighlight| > |CocInfoHighlight| > |CocHintHighlight|

    Document highlight related~  *coc-highlights-document*

        Highlights used for highlighting same symbols in the buffer
        at the current cursor position.
        和某个插件重复了吧

        *CocHighlightText* default symbol highlight.
        *CocHighlightRead* for `Read` kind of document symbol.
        *CocHighlightWrite* for `Write` kind of document symbol.

    Float window/popup related~

        *CocFloating*           floating windows/popups.  Default links to |NormalFloat| on neovim
        *CocFloatDividingLine*  for dividing lines,  links to |NonText| by default.
        *CocErrorFloat*
        *CocWarningFloat*
        *CocInfoFloat*
        *CocHintFloat*

    Notification window/popup related~

        CocNotification 					*CocNotification*

        *CocNotificationProgress*        progress line in progress notification.
        *CocNotificationButton*        action buttons in notification window.
        *CocNotificationError*        highlight border of error notification.
        *CocNotificationWarning*        highlight border of warning notification.
        *CocNotificationInfo*        highlight border of info notification.

    List related~
                                *coc-highlights-list*
        *CocListLine*        current cursor line.
        *CocListSearch*        matched characters.
        *CocListMode*        mode text in the statusline.
        *CocListPath*        cwd text in the statusline.
        *CocSelectedText*        sign text of selected lines (multiple selection only).
        *CocSelectedLine*        line highlight of selected lines (multiple selection only).

    Tree view related~

        CocTree 						*CocTree*

        *CocTreeTitle*        title in tree view.
        *CocTreeDescription*        description beside label.
        *CocTreeOpenClose*        open and close icon in tree view.
        *CocTreeSelected*        highlight lines contains selected node.

    Popup menu related~
                                *CocPum*
        *CocPumSearch*          matched input characters, linked to |CocSearch| by default.
        *CocPumMenu*            menu of complete item.
        *CocPumShortcut*        shortcut text of source
        *CocPumDeprecated*        deprecated label.
        *CocPumVirtualText*       virtual text which enabled by  |coc-config-suggest-virtualText|

    Symbol icons~

        CocSymbol 						*CocSymbol*

        Highlight groups for symbol icons,
            including `CompletionItemKind` and `SymbolKind` of LSP.
        The highlight groups link to related |nvim-treesitter| highlight groups
            when possible and
            fallback to builtin highlight groups.

        *CocSymbolDefault* linked to |hl-MoreMsg| by default.
        *CocSymbolText*
        *CocSymbolUnit*
        *CocSymbolValue*
        *CocSymbolKeyword*
        *CocSymbolSnippet*
        *CocSymbolColor*
        *CocSymbolReference*
        *CocSymbolFolder*
        *CocSymbolFile*
        *CocSymbolModule*
        *CocSymbolNamespace*
        *CocSymbolPackage*
        *CocSymbolClass*
        *CocSymbolMethod*
        *CocSymbolProperty*
        *CocSymbolField*
        *CocSymbolConstructor*
        *CocSymbolEnum*
        *CocSymbolInterface*
        *CocSymbolFunction*
        *CocSymbolVariable*
        *CocSymbolConstant*
        *CocSymbolString*
        *CocSymbolNumber*
        *CocSymbolBoolean*
        *CocSymbolArray*
        *CocSymbolObject*
        *CocSymbolKey*
        *CocSymbolNull*
        *CocSymbolEnumMember*
        *CocSymbolStruct*
        *CocSymbolEvent*
        *CocSymbolOperator*
        *CocSymbolTypeParameter*

        Use configuration |coc-config-suggest-completionItemKindLabels|
            for customized icon  characters.

    Semantic token highlight groups~
                                    *CocSem*

        Semantic highlight groups are starts with `CocSem` which link to related
        |nvim-treesitter| highlight groups when possible and fallback to builtin
        highlight groups, use variable |g:coc_default_semantic_highlight_groups| to
        disable creation of these highlight groups.

        Only semantic tokens types and `deprecated` modifier have default
        highlight groups.

        You need create highlight groups for highlight other modifiers and/or specific
        modifier with type, for example:

            " Add highlights for defaultLibrary modifier
            hi link CocSemDefaultLibrary TSOtherDefaultLibrary
            hi link CocSemDefaultLibraryClass TSTypeDefaultLibrary
            hi link CocSemDefaultLibraryInterface TSTypeDefaultLibrary
            hi link CocSemDefaultLibraryEnum TSTypeDefaultLibrary
            hi link CocSemDefaultLibraryType TSTypeDefaultLibrary
            hi link CocSemDefaultLibraryNamespace TSTypeDefaultLibrary

            " Add highlights for declaration modifier
            hi link CocSemDeclaration TSOtherDeclaration
            hi link CocSemDeclarationClass TSTypeDeclaration
            hi link CocSemDeclarationInterface TSTypeDeclaration
            hi link CocSemDeclarationEnum TSTypeDeclaration
            hi link CocSemDeclarationType TSTypeDeclaration
            hi link CocSemDeclarationNamespace TSTypeDeclaration

        The modifier highlight groups have higher priority.

    Others~

        *CocSearch*          highlight group for matched characters in list.
        *CocDisabled*        highlight for disabled items, eg: menu item.
        *CocCodeLens*            virtual text of codeLens.
        *CocCursorRange*         highlight of activated cursors ranges.
        *CocLinkedEditing*       highlight of activated linked editing ranges.
        *CocHoverRange*          range of current hovered symbol.
        *CocMenuSel*             current menu item in menu dialog (should only provide  background color).
        *CocSelectedRange*       highlight ranges of outgoing calls.
        *CocSnippetVisual*       highlight snippet placeholders.
        *CocInlayHint*           highlight inlay hint virtual text block, default linked to  |CocHintSign|


DIY_again
DIY_2  vim:ft=help:
